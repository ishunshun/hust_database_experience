[toc]

数据库的完整性
		数据的正确性
				是指数据是符合现实世界语义，反映了当前实际状况的
		数据的相容性
				是指数据库同一对象在不同关系表中的数据是符合逻辑的不互相矛盾



数据的完整性和安全性是两个不同概念
		数据的完整性
				防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据
				防范对象：不合语义的、不正确的 数据
		数据的安全性
				保护数据库 防止恶意的破坏和非法的存取
				防范对象：非法用户和非法操作



为维护数据库的完整性，数据库管理系统必须提供完整性控制机制
		定义完整性约束条件
		实施完整性检查，一般在 INSERT 、 UPDATE 、 DELETE 语句执行后开始检查，也可以在事务提交时检查
		如有违反，作何种处置（拒绝、报告、纠正、忽略）

# 1.实体完整性

## 1.实体完整性定义

关系模型的实体完整性
CREATE TABLE 中用 PRIMARY KEY 定义
单属性 构成的码有两种说明方法
		定义为 列级 约束条件
		定义为 表级 约束条件
对 多个属性 构成的码只有一种说明方法
		定义为 表级 约束条件

## 2.实体完整性检查和违约处理

检查 主码值是否唯一 ，如果不唯一则拒绝插入或修改

​		全表扫描、B+树索引

检查 主码 的各个 属性是否为空 ，只要有一个为空就拒绝插入或修改

# 2.参照完整性

## 1.参照完整性定义

关系模型的参照完整性定义
在 CREATE TABLE 中用 FOREIGN KEY 短语定义哪些列为外码
用 REFERENCES 短语指明这些外码参照哪些表的主码

## 2.参照完整性检查和违约处理

一个参照完整性将 两个表中的相应元组 联系起来
对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查



参照完整性违约处理
		拒绝 NO ACTION 执行
				不允许该操作执行。该策略一般设置为 默认策略
		级联 CASCADE 操作
				当删除或修改被参照表 Student 的一个元组造成了与参照表 SC 的不一致，则删除或修改				参照表中的所有造成不一致的元组
		设置为空值 SET NULL
				当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元				组的对应属性设置为空值。

对于参照完整性，除了应该定义外码，还应定义 外码列
是否允许空值

# 3.用户定义的完整性

用户定义的完整性是：针对 某一具体应用 的数据必须满足的语义要求
关系数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担

## 1.属性上的约束条件

CREATE TABLE 时 定义属性上的约束条件
		列值非空（NOT NULL）
		列值唯一（UNIQUE）
		检查列值是否满足一个条件表达式（CHECK）

属性上的约束条件检查和违约处理
		插入元组或修改属性的值时，关系数据库管理系统检查属性上的约束条件是否被满足，如果不		满足则操作被拒绝执行

## 2.元组上的约束条件

在 CREATE TABLE 时可以用 CHECK 短语定义元组上的约束条件，即 元组级的限制
同属性值限制相比，元组级的限制可以设置 不同属性之间 的取值的相互约束条件

元组上的约束条件检查和违约处理
		插入元组或修改属性的值时，关系数据库管理系统检查元组上的约束条件是否被满足
		如果不满足则操作被拒绝执行

# 4.完整性约束命名字句

1.完整性约束命名子句
CONSTRAINT <完整性约束条件名><完整性约束条件>
		<完整性约束条件>包括 NOT NULL 、 UNIQUE 、PRIMARY KEY 短语、 FOREIGN KEY 短语、 	CHECK短语等

2.
修改表中的完整性限制
使用 ALTER TABLE 语句修改表中的完整性限制

# 5.断言

SQL 中，可以使用 CREATE ASSERTION 语句，通过声明性断言来指定 更具一般性的约束 。
可以定义涉及 多个表 的或 聚集操作 的比较复杂的完整性约束。
断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。

## 1.创建断言的语句格式

CREATE ASSERTION< 断言名 ><CHECK 子句>
每个断言 都被赋 予一个名字， <CHECK 子句 >中的约束条件与 WHERE 子句的条件表达式类似。

## 2.删除断言的语句格式

DROP ASSERTION < 断言名>
如果断言很复杂，则系统在检测和维护断言的 开销较高 ，这是在使用断言时应该注意的

# 6.触发器

触发器（ Trigger ）是用户定义在关系表上的一类由 事件驱动 的特殊过程
		触发器保存在数据库服务器中
		任何用户对表的增、删、改操作均由服务器自动激活相应的触发器
		触发器可以实施 更为复杂 的检查和操作，具有更精细和更强大的数据控制能力



触发器的优点
		完成比 CHECK 更复杂的 数据约束。触发器可以引用其他表中的列，还可以插入、更新或删除别的表中的数据；
		触发器也可以评估数据 修改前后的表状态 ，并根据其差异采取对策；
		触发器可以支持约束的所有功能；但它在所给出的功能上并不总是最好的方法。



## 1.定义触发器：

CREATE TRIGGER 语法格式：
CREATE TRIGGER <触发器名 >
{BEFORE | AFTER} <触发事件 > ON 表名
REFERENCING NEW|OLD ROW AS<变量>
FOR EACH {ROW | STATEMENT}
[WHEN <触发条件>]<触发动作体>
触发器又叫做事件-条件-动作 (event condition action )规则。
当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通常是一段SQL 存储过程。



定义触发器的语法说明
		表的 拥有者 才可以在 表 上创建触发器

​		触发器名
​				触发器名可以包含模式名，也可以不包含模式名
​				同一模式下，触发器名必须是 唯一 的
​				触发器名和表名必须在同一模式下

​		表名
​				触发器只能 定义在基本表 上，不能定义在视图上
​				当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器

​		触发事件
​				触发事件可以是 INSERT 、 DELETE 或 UPDATE,也可以是这几个事件的组合	
​				还可以 UPDATE OF< 触发列， ，...>...>，即进一步指明修改哪些列时激活触发器
​				AFTER/BEFORE 是触发的时机
​						AFTER 表示在触发事件的操作执行之后激活触发器
​						BEFORE 表示在触发事件的操作执行之前激活触发器

​		触发器类型
​				行级触发器（ FOR EACH ROW）
​				语句级触发器（ FOR EACH STATEMENT
​				如果是 语句级 触发器，那么执行完该语句后，触发动作只发生一次
​				如果是 行级 触发器，触发动作将执行 1000 次

​		触发条件
​				触发器被激活时，只有当触发条件为真时触发动作体才执行；否则触发动作体不执行。
​				如果省略 WHEN 触发条件，则触发动作体在触发器激活后立即执行。



​		触发动作体
​				触发动作体可以是一个匿名 PL/SQL 过程块,也可以是对已创建存储过程的调用
​				如果是行级触发器，用户都可以在过程体中使用 NEW 和 OLD引用事件之后的新值和事件之前的旧值
​				如果是语句级触发器，则不能在触发动作体中使用 NEW 或OLD 进行引用
​				如果触发动作体执行失败，激活触发器的事件就会终止执行，
​				触发器的目标表或触发器可能影响的其他对象不发生任何变化



约束 vs 触发器 如何选择
		虽然 REFERENCES 子句定义了级联引用操作，但 只能引用原值 。如果两者仅存在某种 映射关系 ，则考虑使用触发器
		CHECK 约束只能根据逻辑表达式或同一表中的 另一列来验证列值。如果应用程序要求根据 另一个表 中的列验证列值，则必须使用触发器



## 2.激活触发器

触发器的执行，是由 触发事件激活 的，并由数据库服务器 自动执行
一个数据表上可能定义了 多个触发器 ，遵循如下的执行顺序
		1 执行该表上的 BEFORE 触发器
		2 激活触发器的 SQL 语句
		3 执行该表上的 AFTER 触发器。



## 3.删除触发器

删除触发器的 SQL 语法：
DROP TRIGGER <触发器名 > ON 表名
触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。
